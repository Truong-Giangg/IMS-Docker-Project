#!KAMAILIO
####### S-CSCF (Kamailio 6.0.x) – minimal, boots cleanly with IMS mods
#include "scscf.cfg"

#### Core
debug=2
children=8
log_stderror=no
auto_aliases=no

listen=udp:0.0.0.0:6060
listen=tcp:0.0.0.0:6060
alias=scscf.ims.sipify

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#### Load order matters
# core helpers
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "xlog.so"
loadmodule "textops.so"
loadmodule "siputils.so"

# RPC (kamcmd) via UNIX binrpc
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# Dialog + Presence (required by IMS usrloc S-CSCF)
loadmodule "dialog.so"
loadmodule "presence.so"
modparam("presence", "subs_db_mode", 0)   # in-memory, no DB required

# IMS dialog helper (REQUIRES a dlg_flag!)
loadmodule "ims_dialog.so"
modparam("ims_dialog", "dlg_flag", 4)     # choose any free flag index (we use 4)

# Diameter + IMS modules
loadmodule "cdp.so"
loadmodule "cdp_avp.so"
loadmodule "ims_auth.so"
loadmodule "ims_usrloc_scscf.so"
loadmodule "ims_registrar_scscf.so"
loadmodule "ims_isc.so"

# CDP uses the XML config file
modparam("cdp", "config_file", "/etc/kamailio/diameter.xml")
# ----- ims_auth (Cx) -----
# "name" is the SIP URI of this S-CSCF (used in Cx messages)
modparam("ims_auth", "name", "sip:scscf.ims.sipify")
# Default AKA/Digest algorithm; pick what your FHOSS users are provisioned with
modparam("ims_auth", "registration_default_algorithm", "MD5")   # or "AKAv1-MD5"
# Force the Cx peer (your HSS Diameter FQDN) and realm
modparam("ims_auth", "cxdx_forced_peer", "hss.ims.sipify")
modparam("ims_auth", "cxdx_dest_realm", "ims.sipify")
# Misc timeouts / checks
modparam("ims_auth", "av_check_only_impu", 1)
modparam("ims_auth", "auth_data_timeout", 5)
modparam("ims_auth", "auth_used_vector_timeout", 300)

# Basic IMS module params (adjust realm to your setup)
modparam("ims_usrloc_scscf", "realm", "ims.sipify")
modparam("ims_usrloc_scscf", "db_mode", 0)          # in-memory

modparam("ims_registrar_scscf", "max_expires", 3600)

####### Routing
request_route {
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    force_rport();
    remove_hf("Route");

    # In-dialog: relay
    if (has_totag()) {
        if (!t_relay()) sl_reply_error();
        exit;
    }

    # Keepalive probes
    if (is_method("OPTIONS") && uri==myself) {
        sl_send_reply("200","OK");
        exit;
    }

    # Registration
    if (is_method("REGISTER")) {
        route(REGISTER);
        exit;
    }

    # For now, reject others
    sl_send_reply("404","Not Here");
    exit;
}

# ---- REGISTER processing ----
route[REGISTER] {
    xlog("L_INFO","S-CSCF REGISTER from $si:$sp\n");
    $var(alg) = "MD5";

#!ifdef WITH_AUTH
    if (!ims_www_authenticate("$td")) {
#!else
    if (($var(alg) == "MD5") && (!ims_www_authenticate("$td"))) {
#!endif
        if ($? == -2) {
            send_reply("403", "Authentication Failed");
            exit;
        } else if ($? == -3) {
            send_reply("400", "Bad Request");
            exit;
        } else if ($? == -9) {
            xlog("L_DBG", "Authentication re-sync requested\n");
            ims_www_resync_auth("REG_RESYNC_REPLY", "$td");
            exit;
        } else {
            # user not authenticated yet — challenge via 401
            xlog("L_DBG","About to challenge! auth_ims\n");
            ims_www_challenge("REG_MAR_REPLY", "$td", "$var(alg)");
            exit;
        }
    } else {
        # xlog("L_DBG", "Auth succeeded\n");
        # Check if user is already registered
        if (!impu_registered("location")) {
            if (!save("PRE_REG_SAR_REPLY","location")) {
                send_reply("500","Registration Save Failed");
            }
            exit;
        } else {
            isc_match_filter_reg("1","location");
            if (!save("REG_SAR_REPLY","location")) {
                send_reply("500","Registration Save Failed");
            }
            exit;
        }
    }
}

route[REG_MAR_REPLY]
{
     #this is async so to know status we have to check the reply avp
     xlog("L_DBG","maa_return code is $avp(s:maa_return_code)\n");
     switch ($avp(s:maa_return_code)){
             case 1: #success
                     xlog("L_DBG", "MAR success - 401/407 response sent from module\n");
                     break;
             case -1: #failure
                     xlog("L_ERR", "MAR failure - error response sent from module\n");
                     break;
             case -2: #error
                     xlog("L_ERR", "MAR error - sending error response now\n");
                     send_reply("503", "MAR failed");
                     break;
             default:
                     xlog("L_ERR", "Unknown return code from MAR, value is [$avp(s:maa_return_code)]\n");
                     send_reply("503", "Unknown response code from MAR");
                     break;
     }
     exit;
}

route[PRE_REG_SAR_REPLY]
{
    xlog("L_DBG","saa_return code is $avp(s:saa_return_code)\n");
        #this is async so to know status we have to check the reply avp
    xlog("L_DBG","saa_return code (for scscf_save on register) is $avp(s:saa_return_code)\n");
    switch ($avp(s:saa_return_code)){
            case 1: #success
                   xlog("L_DBG", "SAR success - 200 response sent from module\n");
                    isc_match_filter_reg("0","location");
                    exit;
            case -1: #failure
                    xlog("L_ERR", "SAR failure - error response sent from module\n");
                    break;
            case -2: #error
                    xlog("L_ERR", "SAR error - error response sent from module\n");
                    break;
            default:
                    xlog("L_ERR", "Unknown return code from SAR, value is [$avp(s:saa_return_code)]\n");
                    break;
    }
    exit;
}

route[REG_SAR_REPLY]
{
    xlog("L_DBG","saa_return code is $avp(s:saa_return_code)\n");
    #this is async so to know status we have to check the reply avp
    xlog("L_DBG","saa_return code (for scscf_save on register) is $avp(s:saa_return_code)\n");
    switch ($avp(s:saa_return_code)){
            case 1: #success
                   xlog("L_DBG", "SAR success - 200 response sent from module\n");
                    exit;
            case -1: #failure
                    xlog("L_ERR", "SAR failure - error response sent from module\n");
                    break;
            case -2: #error
                    xlog("L_ERR", "SAR error - error response sent from module\n");
                    break;
            default:
                    xlog("L_ERR", "Unknown return code from SAR, value is [$avp(s:saa_return_code)]\n");
                    break;
    }
    exit;
}

route[REG_RESYNC_REPLY]
{
     ims_www_challenge("REG_MAR_REPLY", "$td");
}

