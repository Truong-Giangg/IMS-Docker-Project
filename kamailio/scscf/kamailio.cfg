#!KAMAILIO
####### S-CSCF (Kamailio 6.0.x) – minimal, IMS-ready, with de-registration
#include "scscf.cfg"

#### Core
debug=2
children=8
log_stderror=no
auto_aliases=no

listen=udp:0.0.0.0:6060
listen=tcp:0.0.0.0:6060
alias=scscf.local

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#### Load order matters
# core helpers
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "xlog.so"
loadmodule "textops.so"
loadmodule "siputils.so"

# RPC (kamcmd) via UNIX binrpc
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# Dialog + Presence (required by IMS usrloc S-CSCF)
loadmodule "presence.so"
modparam("presence", "subs_db_mode", 0)   # in-memory, no DB required

# IMS dialog helper (REQUIRES a dlg_flag!)
loadmodule "ims_dialog.so"
modparam("ims_dialog", "dlg_flag", 4)     # choose any free flag index (we use 4)

# Diameter + IMS modules
loadmodule "cdp.so"
loadmodule "cdp_avp.so"
loadmodule "ims_auth.so"
loadmodule "ims_usrloc_scscf.so"
loadmodule "ims_registrar_scscf.so"
loadmodule "ims_isc.so"

# ----- CDP -----
modparam("cdp", "config_file", "/etc/kamailio/diameter.xml")
# Optional: relax latency warnings while debugging HSS
# modparam("cdp", "latency_threshold", 2000)

# ----- ims_auth (Cx) -----
# "name" is the SIP URI of this S-CSCF (used in Cx messages)
modparam("ims_auth", "name", "sip:scscf.ims.sipify")
# Default AKA/Digest algorithm; pick what your FHOSS users are provisioned with
modparam("ims_auth", "registration_default_algorithm", "MD5")   # or "AKAv1-MD5"
# Force the Cx peer (your HSS Diameter FQDN) and realm
modparam("ims_auth", "cxdx_forced_peer", "hss.ims.sipify")
modparam("ims_auth", "cxdx_dest_realm", "ims.sipify")
# Misc timeouts / checks
modparam("ims_auth", "av_check_only_impu", 1)
modparam("ims_auth", "auth_data_timeout", 5)
modparam("ims_auth", "auth_used_vector_timeout", 300)

# ----- IMS usrloc/registrar -----
modparam("ims_usrloc_scscf", "realm", "ims.sipify")
modparam("ims_usrloc_scscf", "db_mode", 0)          # in-memory
modparam("ims_registrar_scscf", "max_expires", 3600)

####### Routing
request_route {
    if (!mf_process_maxfwd_header(10)) {
        sl_send_reply("483", "Too Many Hops"); exit;
    }

    force_rport();
    remove_hf("Route");

    # mark dialog-forming requests so ims_dialog initializes
    if (is_method("INVITE|SUBSCRIBE|UPDATE|MESSAGE")) {
        setflag(4);            # must match ims_dialog:dlg_flag
        record_route();
    }

    # in-dialog? relay
    if (has_totag()) { t_relay(); exit; }

    # health
    if (is_method("OPTIONS") && uri==myself) {
        sl_send_reply("200","OK"); exit;
    }

    # very simple REGISTER stub (no Cx yet) – proves modules are up
    if (is_method("REGISTER")) {
        sl_send_reply("200","OK"); exit;
    }

    # --- Optional terminating-side UNREG assignment (per your ref) ---
    # If request targets a local IMPU (or tel:) and it's NOT registered, do UNREG assign
    if ((uri == myself) || $ru =~ "tel:.*") {
        if (!term_impu_registered("location")) {
            xlog("L_DBG", "Terminating to unregistered IMPU -> UNREG assign\n");
            assign_server_unreg("UNREG_SAR_REPLY", "location", "term");
            exit;
        }
    } else {
        sl_send_reply("403","Forbidden - Domain not served");
        exit;
    }

    # For now, reject others
    sl_send_reply("404","Not Here");
    exit;
}

# ---- REGISTER processing ----
route[REGISTER] {
    xlog("L_INFO","S-CSCF REGISTER from $si:$sp\n");
    $var(alg) = "MD5";

    # --- Detect UE De-Registration (RFC3261) ---
    $var(dereg) = 0;
    if ($hdr(Expires) == "0") {
        $var(dereg) = 1;
    }
    # ---- OPTIONAL: unauthenticated de-reg fast-path
    if ($var(dereg) == 1 && $hdr(Authorization) == $null && $hdr(Proxy-Authorization) == $null) {
        if (impu_registered("location")) {
            xlog("L_DBG","Unauthenticated de-reg fast-path\n");
            if (!save("UNREG_SAR_REPLY","location")) {
                sl_send_reply("500","De-Registration Failed");
            }
            exit;
        } else {
            # nothing to remove
            sl_send_reply("200","OK");
            exit;
        }
    }

#!ifdef WITH_AUTH
    if (!ims_www_authenticate("$td")) {
#!else
    if (($var(alg) == "MD5") && (!ims_www_authenticate("$td"))) {
#!endif
        if ($? == -2) {
            sl_send_reply("403", "Authentication Failed");
            exit;
        } else if ($? == -3) {
            sl_send_reply("400", "Bad Request");
            exit;
        } else if ($? == -9) {
            xlog("L_DBG", "Authentication re-sync requested\n");
            ims_www_resync_auth("REG_RESYNC_REPLY", "$td");
            exit;
        } else {
            # user not authenticated yet — challenge via 401
            xlog("L_DBG","About to challenge! auth_ims\n");
            ims_www_challenge("REG_MAR_REPLY", "$td", "$var(alg)");
            exit;
        }
    } else {
        if ($var(dereg) == 1) {
            xlog("L_DBG","UE requested de-registration\n");
            isc_match_filter_reg("2","location");
            if (!save("UNREG_SAR_REPLY","location")) {
                sl_send_reply("500","De-Registration Failed");
            }
            exit;   # registrar will send final reply when SAA arrives
        }
        # --- Normal registration flow ---
        if (!impu_registered("location")) {
            if (!save("PRE_REG_SAR_REPLY","location")) {
                sl_send_reply("500","Registration Save Failed");
            }
            exit;
        } else {
            isc_match_filter_reg("1","location");
            if (!save("REG_SAR_REPLY","location")) {
                sl_send_reply("500","Registration Save Failed");
            }
            exit;
        }
    }
}

# ---- Async callbacks (must not send final SIP replies unless noted) ----

route[REG_MAR_REPLY]
{
     # this is async; check reply AVP
     xlog("L_DBG","maa_return_code is $avp(s:maa_return_code)\n");
     switch ($avp(s:maa_return_code)){
         case 1:  # success
             xlog("L_DBG", "MAR success - 401/407 response sent from module\n");
             break;
         case -1: # failure
             xlog("L_ERR", "MAR failure - error response sent from module\n");
             break;
         case -2: # error
             xlog("L_ERR", "MAR error - sending error response now\n");
             sl_send_reply("503", "MAR failed");
             break;
         default:
             xlog("L_ERR", "Unknown return code from MAR, value is [$avp(s:maa_return_code)]\n");
             sl_send_reply("503", "Unknown response code from MAR");
             break;
     }
     exit;
}

route[PRE_REG_SAR_REPLY]
{
    xlog("L_DBG","saa_return_code (PRE_REG) is $avp(s:saa_return_code)\n");
    # async; module normally sends final 200 on success
    switch ($avp(s:saa_return_code)){
        case 1:  # success
            xlog("L_DBG", "SAR success (PRE_REG) - 200 sent by module\n");
            isc_match_filter_reg("0","location");
            break;
        case -1: # failure
            xlog("L_ERR", "SAR failure (PRE_REG) - error sent by module\n");
            break;
        case -2: # error
            xlog("L_ERR", "SAR error (PRE_REG) - error sent by module\n");
            break;
        default:
            xlog("L_ERR", "Unknown SAR code (PRE_REG): [$avp(s:saa_return_code)]\n");
            break;
    }
    exit;
}

route[REG_SAR_REPLY]
{
    xlog("L_DBG","saa_return_code (REG) is $avp(s:saa_return_code)\n");
    # async; module normally sends final 200 on success
    switch ($avp(s:saa_return_code)){
        case 1:  # success
            xlog("L_DBG", "SAR success (REG) - 200 sent by module\n");
            break;
        case -1: # failure
            xlog("L_ERR", "SAR failure (REG) - error sent by module\n");
            break;
        case -2: # error
            xlog("L_ERR", "SAR error (REG) - error sent by module\n");
            break;
        default:
            xlog("L_ERR", "Unknown SAR code (REG): [$avp(s:saa_return_code)]\n");
            break;
    }
    exit;
}

route[UNREG_SAR_REPLY]
{
    xlog("L_DBG","saa_return_code (UNREG) is $avp(s:saa_return_code)\n");
    # async; module normally sends the final 200 on success
    switch ($avp(s:saa_return_code)){
        case 1:  # success
            xlog("L_DBG","UNREG SAR success - 200 sent by module\n");
            break;
        case -1: # failure
            xlog("L_ERR","UNREG SAR failure - error sent by module\n");
            break;
        case -2: # error
            xlog("L_ERR","UNREG SAR error - error sent by module\n");
            break;
        default:
            xlog("L_ERR","UNREG SAR unknown code [$avp(s:saa_return_code)]\n");
            break;
    }
    exit;
}

route[REG_RESYNC_REPLY]
{
    # UE requested resync; re-issue challenge
    ims_www_challenge("REG_MAR_REPLY", "$td");
    exit;
}
